#define queueAmount 5
#define cashboxesAm 2
#define patience 10
#define service_time 2
#define time 15

mtype = { WAIT_P, PAY, WAIT_A, ACTION, GONE_AFTER_ACTION, GONE_AFTER_WAITING }; 
mtype = { FREE, BUSY }; //Deck states

mtype men[queueAmount] = WAIT_P;

mtype decks[cashboxesAm] = FREE;

int mans_queue [queueAmount]= -1;
int rand_value;
int waiting_time[queueAmount] = 0 
int t = 0;

proctype cashboxesAction(int id)
{
	int man_id = 0;
	int internal_time = 1;
	int time_for_pay = 1;
	do
	:: (t <= time) ->
		//(t == internal_time) -> internal_time = internal_time + 1;
		atomic {
			printf("status:%d", decks[id]);
			if
			:: (decks[id] == FREE) ->
				do
				::
					if
					:: (mans_queue > -1) ->
					//mans_queue ? man_id;
						
						man_id= mans_queue;
						decks[id] = BUSY;
						if
						:: (men[man_id] == WAIT_P) -> men[man_id] = PAY;
						fi
					:: else -> 
						printf("wrong id: %d",mans_queue);
						skip;
					fi
				od
			:: (decks[id] == BUSY) -> 
				if
				:: (time_for_pay < service_time ) -> 
					time_for_pay = time_for_pay + 1;
				:: (time_for_pay >= service_time) ->
					//(men[man_id] == PAY) ->
						men[man_id] = WAIT_A;
						printf("one more person serviced");
					decks[id] = FREE;
					//mans_queue ! man_id;
					time_for_pay = 1;
				fi
			else -> 
				printf("Some error 49\n"); 
				printf("Deck with id %d value is %d\n", id, decks[id]);
				break;
			fi
		}
		t = t + 1;
	od
}

proctype queueAction(int id)
{
	int internal_time = 1;
	do :: (t <= time) ->
		//(t == internal_time) -> internal_time = internal_time + 1;
		atomic {
			if
			:: (men[id] == WAIT_P) -> 
				if
				:: ( waiting_time[id] < patience) -> 
					waiting_time[id] = waiting_time[id] + 1;
					printf("Man %d waiting", id);
				:: ( waiting_time[id] >= patience) -> 
					men[id] = GONE_AFTER_WAITING;
					printf("Man %d go after waiting", id);
				fi
				;
			:: (men[id] == PAY) -> 
				printf("Man %d pays \n", id);
			:: (men[id] == WAIT_A) ->
				men[id] = ACTION;
				printf("Man %d waits for action\n", id);
			:: (men[id] == ACTION) ->
				men[id] = GONE_AFTER_ACTION;
				printf("Man %d ride on Buster\n", id);

			:: else -> 
				break;
			fi
		}
		:: else -> break;
	od
	
}

proctype new_queue_gen() {
//	int man_id = queueAmount-1;
	mans_queue[0] = 0;
	mans_queue[1] = 1;
	mans_queue[2] = 2;
	mans_queue[3] = 3;
	mans_queue[4] = 4;
	//do
//	::
//		atomic {
			//printf("man_id value in gen: %d\n", man_id);
//			if 
//			:: (man_id < 0 ) -> skip;
//			fi
//			men[man_id] = WAIT_P;
//			mans_queue = man_id;
//			man_id = man_id - 1;
//		}
//	:: else -> break;
//	od
	printf("Gen stops\n");
}

init {
	int i;
	printf("Init model\n");
	atomic {
		run new_queue_gen();
		for(i: 0 .. (queueAmount - 1)){
			run queueAction(i);
		}
		for(i: 0 .. (cashboxesAm - 1)){
			run cashboxesAction(i);
		}
	}
}

ltl free_decks{
	<>[] (decks[0] == FREE && decks[1] == FREE)
}

ltl all_slope{ 
	<>[] (len(mans_queue) == 0)
}

ltl pay_slope{ 
	[]((men[0] == WAIT_P)->(<>(men[0] == ACTION)))
	&&
	[]((men[1] == WAIT_P)->(<>(men[1] == ACTION)))
	&&
	[]((men[2] == WAIT_P)->(<>(men[2] == ACTION)))
	&&
	[]((men[3] == WAIT_P)->(<>(men[3] == ACTION)))
	&&
	[]((men[4] == WAIT_P)->(<>(men[4] == ACTION)))
}

ltl slope_fifo{
	[] ((men[0] == ACTION) implies ((men[1] == WAIT_A))) &&
	[] ((men[1] == WAIT_A) implies ((men[2] == PAY))) &&
	[] ((men[2] == PAY) implies ((men[3] == WAIT_P)))
}

ltl queue_patience {
	[]( !((men[1] == WAIT_P) && ((t - waiting_time[1]) > patience)))
}
